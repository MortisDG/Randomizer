;;-*-Lisp-*-
(in-package goal)

;; name: custom-pickup-type.gc
;; name in dgo: custom-pickup-type
;; dgos: TODO






(defpartgroup group-eco-pink
  :id 481
  :bounds (static-bspherem 0 0 0 1)
  :parts ((sp-item 160 :flags (launch-asap) :binding 1611)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 1611 :flags (start-dead launch-asap) :binding 1621)
    (sp-item 162 :flags (start-dead launch-asap) :binding 163)
    (sp-item 162 :flags (start-dead launch-asap) :binding 163)
    (sp-item 162 :flags (start-dead launch-asap) :binding 163)
    (sp-item 163 :fade-after (meters 100) :flags (start-dead launch-asap) :binding 164)
    (sp-item 163 :fade-after (meters 100) :flags (start-dead launch-asap) :binding 164)
    (sp-item 163 :fade-after (meters 100) :flags (start-dead launch-asap) :binding 164)
    (sp-item 164 :fade-after (meters 90) :falloff-to (meters 110) :flags (start-dead))
    (sp-item 164 :fade-after (meters 90) :falloff-to (meters 110) :flags (start-dead))
    (sp-item 164 :fade-after (meters 90) :falloff-to (meters 110) :flags (start-dead))
    )
  )


  (defpartgroup group-eco-pink-collect
  :id 49
  :duration 150
  :linger-duration 600
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 12)
  :parts ((sp-item 168 :flags (launch-asap) :binding 169)
    (sp-item 169 :flags (start-dead launch-asap) :binding 170)
    (sp-item 169 :flags (start-dead launch-asap) :binding 170)
    (sp-item 169 :flags (start-dead launch-asap) :binding 170)
    (sp-item 169 :flags (start-dead launch-asap) :binding 170)
    (sp-item 169 :flags (start-dead launch-asap) :binding 170)
    (sp-item 170 :fade-after (meters 40) :flags (start-dead))
    (sp-item 170 :fade-after (meters 40) :flags (start-dead))
    (sp-item 170 :fade-after (meters 40) :flags (start-dead))
    (sp-item 170 :fade-after (meters 40) :flags (start-dead))
    (sp-item 170 :fade-after (meters 40) :flags (start-dead))
    )
  )

(defpart 1611
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :page #x2))
    (sp-flt spt-num 6.0)
    (sp-rnd-flt spt-y (meters 0) (meters 16) 1.0)
    (sp-rnd-flt spt-z (meters 0.15) (meters 0.2) 1.0)
    (sp-rnd-flt spt-scale-x (meters 2) (meters 2) 1.0)
    (sp-rnd-flt spt-rot-z (degrees 0.0) (degrees 360.0) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 0.0)
    (sp-flt spt-b 255.0)
    (sp-flt spt-a 24.0)
    (sp-rnd-flt spt-omega 0.0 65536.0 1.0)
    (sp-rnd-flt spt-vel-x (meters 0.0148148155) (meters 0.0044444446) 1.0)
    (sp-flt spt-vel-y (meters 0))
    (sp-flt spt-vel-z (meters 0))
    (sp-rnd-int-flt spt-rotvel-z (degrees -0.1) 1 36.40889)
    (sp-int spt-timer -1)
    (sp-cpuinfo-flags bit3 bit7 bit14)
    (sp-func spt-func 'eco-fadeout)
    (sp-int spt-next-time 10)
    (sp-launcher-by-id spt-next-launcher 165)
    )
  )

  (defpart 1621
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #xf :page #x2))
    (sp-flt spt-num 1.0)
    (sp-rnd-flt spt-y (meters 0) (meters 16) 1.0)
    (sp-rnd-flt spt-z (meters 0.25) (meters 0.1) 1.0)
    (sp-rnd-flt spt-scale-x (meters 0.6) (meters 0.4) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 0.0)
    (sp-flt spt-b 255.0)
    (sp-flt spt-a 32.0)
    (sp-rnd-flt spt-omega 0.0 65536.0 1.0)
    (sp-rnd-flt spt-vel-x (meters 0.017777778) (meters 0.0148148155) 1.0)
    (sp-flt spt-vel-y (meters 0))
    (sp-flt spt-vel-z (meters 0))
    (sp-int spt-timer -1)
    (sp-cpuinfo-flags bit2 bit3 bit7 bit14)
    (sp-func spt-func 'eco-fadeout)
    (sp-int spt-next-time 10)
    (sp-launcher-by-id spt-next-launcher 166)
    )
  )

(defpart 165
  :init-specs ((sp-flt spt-fade-a -0.16) (sp-int spt-timer 150))
  )

(defpart 166
  :init-specs ((sp-flt spt-fade-a -0.21333334) (sp-int spt-timer 150))
  )

(defpart 162
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #xf :page #x2))
    (sp-flt spt-num 1.0)
    (sp-rnd-flt spt-y (meters 0) (meters 16) 1.0)
    (sp-rnd-flt spt-z (meters 0.25) (meters 0.1) 1.0)
    (sp-rnd-flt spt-scale-x (meters 0.6) (meters 0.4) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-rnd-flt spt-r 128.0 128.0 1.0)
    (sp-rnd-flt spt-g 64.0 64.0 1.0)
    (sp-flt spt-a 32.0)
    (sp-rnd-flt spt-omega 0.0 65536.0 1.0)
    (sp-rnd-flt spt-vel-x (meters 0.017777778) (meters 0.0148148155) 1.0)
    (sp-flt spt-vel-y (meters 0))
    (sp-flt spt-vel-z (meters 0))
    (sp-int spt-timer -1)
    (sp-cpuinfo-flags bit2 bit3 bit7 bit14)
    (sp-func spt-func 'eco-fadeout)
    (sp-int spt-next-time 10)
    (sp-launcher-by-id spt-next-launcher 166)
    )
  )

(defpart 168
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #x12 :page #x2))
    (sp-flt spt-num 1.0)
    (sp-flt spt-scale-x (meters 4))
    (sp-rnd-flt spt-rot-z (degrees 0.0) (degrees 360.0) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-rnd-flt spt-r 128.0 128.0 1.0)
    (sp-rnd-flt spt-g 0.0 64.0 1.0)
    (sp-flt spt-b 0.0)
    (sp-flt spt-a 128.0)
    (sp-flt spt-fade-a -3.2)
    (sp-int spt-timer 150)
    (sp-cpuinfo-flags bit3 bit14)
    (sp-func spt-func 'part-tracker-track-root)
    (sp-int spt-next-time 15)
    (sp-launcher-by-id spt-next-launcher 148)
    )
  )

(defpart 169
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #xf :page #x2))
    (sp-flt spt-num 5.0)
    (sp-rnd-flt spt-y (meters -4) (meters 16) 1.0)
    (sp-flt spt-z (meters 0.08))
    (sp-rnd-flt spt-scale-x (meters 0.3) (meters 0.2) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 128.0)
    (sp-flt spt-b 0.0)
    (sp-flt spt-a 127.0)
    (sp-rnd-flt spt-omega 0.0 65536.0 1.0)
    (sp-rnd-flt spt-vel-x (meters -0.017777778) (meters 0.00048828125) 145.63556)
    (sp-flt spt-vel-y (meters 0))
    (sp-flt spt-vel-z (meters 0.08))
    (sp-flt spt-accel-z -21.845333)
    (sp-int spt-timer 150)
    (sp-cpuinfo-flags bit2 bit3 bit7 bit14)
    )
  )

(defpart 170
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :page #x2))
    (sp-flt spt-num 1.0)
    (sp-rnd-flt spt-scale-x (meters 1) (meters 0.5) 1.0)
    (sp-rnd-flt spt-rot-z (degrees 0.0) (degrees 360.0) 1.0)
    (sp-copy-from-other spt-scale-y -4)
    (sp-rnd-flt spt-r 100.0 28.0 1.0)
    (sp-rnd-flt spt-g 64.0 64.0 1.0)
    (sp-flt spt-b 0.0)
    (sp-rnd-flt spt-a 64.0 32.0 1.0)
    (sp-rnd-flt spt-vel-y (meters 0.0033333334) (meters 0.006666667) 1.0)
    (sp-flt spt-scalevel-x (meters -0.005555555))
    (sp-rnd-flt spt-rotvel-z (degrees -1.2) (degrees 2.4) 1.0)
    (sp-copy-from-other spt-scalevel-y -4)
    (sp-flt spt-fade-g -2.0)
    (sp-flt spt-fade-a -0.22857143)
    (sp-rnd-flt spt-accel-y 0.40960002 0.6144 1.0)
    (sp-int spt-timer 54)
    (sp-cpuinfo-flags bit2 bit3 bit14)
    (sp-int spt-next-time 240)
    (sp-launcher-by-id spt-next-launcher 171)
    )
  )

  (defpart 171
  :init-specs ((sp-flt spt-fade-g 0.0))
  )


(defpart 245
  :init-specs ((sp-flt spt-scalevel-x (meters -0.025)) (sp-copy-from-other spt-scalevel-y -4))
  )

(defpartgroup group-pink-collect
  :id 1612
  :duration 5
  :linger-duration 1200
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 12)
  :parts ((sp-item 2521) (sp-item 2531) (sp-item 2541))
  )

(defpart 2521
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #x2 :page #x2))
    (sp-flt spt-num 16.0)
    (sp-rnd-flt spt-scale-x (meters 6) (meters 1) 1.0)
    (sp-int spt-rot-x 4)
    (sp-rnd-flt spt-rot-z (degrees 0.0) (degrees 360.0) 1.0)
    (sp-rnd-flt spt-scale-y (meters 0.5) (meters 1) 1.0)
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 0.0)
    (sp-flt spt-b 255.0)
    (sp-flt spt-a 0.0)
    (sp-flt spt-scalevel-x (meters 0.009765625))
    (sp-rnd-flt spt-rotvel-z (degrees -0.3) (degrees 0.6) 1.0)
    (sp-flt spt-scalevel-y (meters 0.009765625))
    (sp-flt spt-fade-a 2.1333334)
    (sp-int spt-timer 450)
    (sp-cpuinfo-flags bit2 bit3 bit14)
    (sp-func spt-func 'sparticle-track-root)
    (sp-int-plain-rnd spt-next-time 5 19 1)
    (sp-launcher-by-id spt-next-launcher 244)
    )
  )

(defpart 2531
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #x2 :page #x2))
    (sp-flt spt-num 6.0)
    (sp-rnd-flt spt-scale-x (meters 8) (meters 2) 1.0)
    (sp-int spt-rot-x 4)
    (sp-rnd-flt spt-rot-z (degrees 0.0) (degrees 360.0) 1.0)
    (sp-flt spt-scale-y (meters 0.5))
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 0.0)
    (sp-flt spt-b 255.0)
    (sp-flt spt-a 0.0)
    (sp-flt spt-scalevel-x (meters 0.009765625))
    (sp-rnd-flt spt-rotvel-z (degrees -0.3) (degrees 0.6) 1.0)
    (sp-flt spt-fade-a 2.1333334)
    (sp-int spt-timer 450)
    (sp-cpuinfo-flags bit2 bit3 bit14)
    (sp-func spt-func 'sparticle-track-root)
    (sp-int-plain-rnd spt-next-time 5 19 1)
    (sp-launcher-by-id spt-next-launcher 244)
    )
  )

(defpart 2541
  :init-specs ((sp-tex spt-texture (new 'static 'texture-id :index #x12 :page #x2))
    (sp-flt spt-num 1.0)
    (sp-flt spt-scale-x (meters 6))
    (sp-flt spt-rot-z (degrees 0.0))
    (sp-copy-from-other spt-scale-y -4)
    (sp-flt spt-r 255.0)
    (sp-flt spt-g 0.0)
    (sp-flt spt-b 255.0)
    (sp-flt spt-a 128.0)
    (sp-flt spt-scalevel-x (meters 0.1))
    (sp-flt spt-rotvel-z (degrees -0.8))
    (sp-copy-from-other spt-scalevel-y -4)
    (sp-flt spt-fade-a -0.42666668)
    (sp-int spt-timer 300)
    (sp-cpuinfo-flags bit2 bit3 bit14)
    (sp-func spt-func 'sparticle-track-root)
    (sp-int spt-next-time 60)
    (sp-launcher-by-id spt-next-launcher 245)
    )
  )

 (defpart 244
  :init-specs ((sp-flt spt-fade-a -0.15238096))
  ) 

  (defmethod initialize-effect eco-collectable ((obj eco-collectable) (arg0 pickup-type))
  (set! (-> obj fact pickup-type) arg0)
  (case (-> obj fact pickup-type)
    (((pickup-type eco-blue) (pickup-type eco-red) (pickup-type eco-green) (pickup-type eco-yellow) (pickup-type eco-pink))
     (logclear! (-> obj mask) (process-mask actor-pause))
     )
    )
  (set! (-> obj sound-name) #f)
  (case arg0
    (((pickup-type eco-yellow))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 56))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 68))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 57))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     (set! (-> obj sound-name) (static-sound-spec "yel-eco-idle" :fo-max 15))
     )
    (((pickup-type eco-red))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 48))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 69))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 49))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     (set! (-> obj sound-name) (static-sound-spec "red-eco-idle" :fo-max 15))
     )
    (((pickup-type eco-pink))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 481))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 1612))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 43))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     (set! (-> obj sound-name) (static-sound-spec "red-eco-idle" :fo-max 15))
     )
    (((pickup-type eco-blue))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 42))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 67))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 43))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     (set! (-> obj sound-name) (static-sound-spec "blue-eco-idle" :fo-max 15))
     )
    (((pickup-type eco-green))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 58))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 66))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 61))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     (set! (-> obj sound-name) (static-sound-spec "green-eco-idle" :fo-max 15))
     )
    (((pickup-type eco-pill))
     (set! (-> obj eco-effect) (-> *part-group-id-table* 59))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 60))
     (set! (-> obj collect-effect-time) (seconds 0.5))
     )
    )
  (set! (-> obj part) (create-launch-control (-> obj eco-effect) obj))
  (if (-> obj sound-name)
      (set! (-> obj sound) (new 'process 'ambient-sound (-> obj sound-name) (-> obj root-override trans)))
      )
  (none)
  )


(defstate pickup (eco-collectable)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'set-movie-pos)
           (let ((v1-3 (res-lump-struct (-> self entity) 'movie-pos vector :time (the-as float -1000000000.0))))
             (the-as symbol (when v1-3
                              (set! (-> v1-3 quad) (-> (the-as vector (-> arg3 param 0)) quad))
                              (the-as symbol v1-3)
                              )
                     )
             )
           )
          ((= v1-0 'actor-pause)
           (the-as symbol (cond
                            ((-> arg3 param 0)
                             (logior! (-> self mask) (process-mask actor-pause))
                             (let ((v0-1 #t))
                               (set! (-> self actor-pause) v0-1)
                               v0-1
                               )
                             )
                            (else
                              (logclear! (-> self mask) (process-mask actor-pause))
                              (set! (-> self actor-pause) #f)
                              #f
                              )
                            )
                   )
           )
          ((= v1-0 'fade)
           (process-entity-status! self (entity-perm-status dead) #t)
           (the-as symbol (deactivate self))
           )
          )
        )
      )
    )
  :enter (behavior ((arg0 object) (arg1 handle))
    (set! (-> self pickup-handle) arg1)
    (when (-> self notify-parent)
      (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> gp-0 from) self)
        (set! (-> gp-0 num-params) 1)
        (set! (-> gp-0 message) 'notify)
        (set! (-> gp-0 param 0) (the-as uint 'pickup))
        (let ((s5-0 send-event-function)
              (s4-0 (ppointer->process (-> self parent)))
              )
          (s5-0
            (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) process))
                s4-0
                )
            gp-0
            )
          )
        )
      )
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :code (behavior ((arg0 object) (arg1 handle))
    (clear-collide-with-as (-> self root-override))
    (if (not (or (= (-> self fact pickup-type) (pickup-type eco-pill))
                 (logtest? (-> self fact options) (fact-options powerup))
                 )
             )
        (send-event (handle->process arg1) 'powerup (-> self fact pickup-type) (-> self fact pickup-amount))
        )
    (if (nonzero? (-> self sound))
        (stop! (-> self sound))
        )
    (case (-> self fact pickup-type)
      (((pickup-type eco-yellow))
       (sound-play "y-eco-pickup")
       )
      (((pickup-type eco-red))
       (sound-play "r-eco-pickup")
       )
      (((pickup-type eco-pink))
       (sound-play "r-eco-pickup")
       )
      (((pickup-type eco-blue))
       (sound-play "b-eco-pickup")
       (case (-> (level-get-target-inside *level*) name)
         (('training)
          (level-hint-spawn
            (game-text-id training-eco-reminder)
            "sagevb23"
            (the-as entity #f)
            *entity-pool*
            (game-task none)
            )
          )
         )
       )
      (((pickup-type eco-green))
       (sound-play "g-eco-pickup")
       )
      (((pickup-type eco-green) (pickup-type eco-pill))
       (sound-play "pill-pickup")
       )
      )
    (if (nonzero? (-> self part))
        (kill-and-free-particles (-> self part))
        )
    (let ((gp-6 (handle->process (-> self pickup-handle))))
      (if (nonzero? (-> self collect-effect))
          (process-spawn
            part-tracker
            :init part-tracker-init
            (-> self collect-effect)
            -1
            part-tracker-track-target
            #f
            #f
            (-> self root-override root-prim prim-core)
            :to gp-6
            )
          )
      )
    (if (nonzero? (-> self collect-effect2))
        (process-spawn
          part-tracker
          :init part-tracker-init
          (-> self collect-effect2)
          -1
          (lambda ((arg0 part-tracker))
            (let ((s5-0 (handle->process (-> arg0 userdata))))
              (when s5-0
                (let* ((v1-4 (handle->process (-> (the-as eco-collectable s5-0) pickup-handle)))
                       (a2-0 (cond
                               ((not v1-4)
                                (-> arg0 root trans)
                                )
                               ((= (-> v1-4 type) target)
                                (vector<-cspace! (new 'stack-no-clear 'vector) (-> (the-as target v1-4) node-list data 5))
                                )
                               (else
                                 (-> (the-as target v1-4) control trans)
                                 )
                               )
                             )
                       )
                  (vector-lerp!
                    (-> arg0 root trans)
                    (-> arg0 offset)
                    a2-0
                    (/ (the float (- (-> *display* base-frame-counter) (-> arg0 start-time)))
                       (the float (-> (the-as eco-collectable s5-0) collect-effect-time))
                       )
                    )
                  )
                )
              )
            )
          (process->handle self)
          #f
          (-> self root-override root-prim prim-core)
          :to self
          )
        )
    (while (-> self child)
      (suspend)
      )
    (go-virtual die)
    (none)
    )
  )


(defbehavior initialize-eco-by-other eco ((arg0 vector) (arg1 vector) (arg2 fact-info))
  (let ((s3-0 (-> arg2 pickup-type))
        (f30-0 (-> arg2 pickup-spawn-amount))
        )
    (set! (-> self pickup-amount) f30-0)
    (set! (-> self pickup-type) s3-0)
    (initialize self)
    (set! (-> self fact pickup-type) s3-0)
    (set! (-> self fact pickup-amount) f30-0)
    )
  (set! (-> self fact options) (-> arg2 options))
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set! (-> self root-override transv quad) (-> arg1 quad))
  (initialize-effect self (-> self fact pickup-type))
  (set! (-> self notify-parent) #f)
  (case (-> self fact pickup-type)
    (((pickup-type eco-blue) (pickup-type eco-yellow) (pickup-type eco-red) (pickup-type eco-pink))
     (initialize-params
       self
       (the-as time-frame (if (and arg2 (logtest? (-> arg2 options) (fact-options fade)))
                              (the-as int (-> arg2 fade-time))
                              0
                              )
               )
       (the-as float 1024.0)
       )
     )
    (else
      (initialize-params self (seconds 15) (the-as float 1024.0))
      )
    )
  (update-transforms! (-> self root-override))
  (set! (-> self event-hook) (-> (method-of-object self wait) event))
  (if (logtest? (fact-options eco-blocked) (-> self fact options))
      (go-virtual blocked)
      )
  (go-virtual wait)
  (none)
  )


  
 (deftype eco-pink (eco)
  ()
  :heap-base #x130
  :method-count-assert 31
  :size-assert         #x194
  :flag-assert         #x1f01300194
  )

(defun spawnpink ()
(birth-pickup-at-point (vector+float! (new-stack-vector0) (-> *target* root trans) (meters 2.0)) (pickup-type eco-pink) 1.0 #f *target* (the-as fact-info #f))
(none))

(defmethod init-from-entity! eco-pink ((obj eco-pink) (arg0 entity-actor))
  (initialize-eco obj arg0 (pickup-type eco-pink) (-> *FACT-bank* eco-single-inc))
  (none)
  )



(defmethod init-from-entity! eco ((obj eco) (arg0 entity-actor))
  (let ((v1-2 (res-lump-value (-> obj entity) 'eco-info pickup-type :time (the-as float -1000000000.0))))
    (set! (-> obj type) (cond
                          ((= v1-2 (pickup-type eco-blue))
                           eco-blue
                           )
                          ((= v1-2 (pickup-type eco-red))
                           eco-red
                           )
                          ((= v1-2 (pickup-type eco-yellow))
                           eco-yellow
                           )
                          ((= v1-2 (pickup-type eco-pink))
                           eco-pink
                           )
                          ((= v1-2 (pickup-type eco-green))
                           health
                           )
                          ((= v1-2 (pickup-type money))
                           money
                           )
                          ((= v1-2 (pickup-type fuel-cell))
                           fuel-cell
                           )
                          ((= v1-2 (pickup-type buzzer))
                           buzzer
                           )
                          (else
                            eco-pill
                            )
                          )
          )
    )
  (init-from-entity! obj arg0)
  (none)
  )


(defbehavior birth-pickup-at-point process ((arg0 vector) (arg1 pickup-type) (arg2 float) (arg3 symbol) (arg4 process-tree) (arg5 fact-info))
  (local-vars
    (v1-2 basic)
    (v1-28 symbol)
    (v1-34 symbol)
    (v1-40 symbol)
    (v1-46 symbol)
    (v1-52 symbol)
    (v1-58 symbol)
    (v1-64 symbol)
    (v1-71 symbol)
    (sv-32 fact-info)
    (sv-48 int)
    (sv-64 process)
    (sv-80 process)
    (sv-96 process)
    (sv-112 process)
    (sv-128 process)
    (sv-144 process)
    (sv-160 process)
    (sv-176 process)
    (sv-192 (pointer process))
    )
  (set! sv-32 arg5)
  (let ((s1-0 (new-stack-vector0))
        (t9-0 (method-of-type res-lump get-property-value-float))
        )
    (let ((v1-1 sv-32))
      (b! (not v1-1) cfg-3 :likely-delay (set! v1-2 sv-32))
      )
    (set! v1-2 (nonzero? (-> sv-32 process)))
    (label cfg-3)
    (let ((f30-0 (t9-0
                   (if v1-2
                       (-> sv-32 process entity)
                       )
                   'pickup-radius
                   'interp
                   (the-as float -1000000000.0)
                   (the-as float (cond
                                   ((= arg1 (pickup-type buzzer))
                                    0.0
                                    )
                                   ((= arg2 1.0)
                                    409.6
                                    )
                                   (else
                                     8192.0
                                     )
                                   )
                           )
                   (the-as (pointer res-tag) #f)
                   *res-static-buf*
                   )
                 )
          )
      (set! sv-192 (the-as (pointer process) #f))
      (set! sv-48 (the int arg2))
      (let ((s0-0 (new 'static 'fact-info)))
        (set! (-> s0-0 options) (fact-options))
        (if sv-32
            (mem-copy! (&-> s0-0 type) (&-> sv-32 type) 40)
            )
        (set! (-> s0-0 pickup-type) arg1)
        (set! (-> s0-0 pickup-spawn-amount) 1.0)
        (while (> sv-48 0)
          (set! sv-48 (+ sv-48 -1))
          (when arg3
            (set-vector! s1-0 0.0 57001.605 f30-0 1.0)
            (vector-rotate-around-y! s1-0 s1-0 (/ (* 65536.0 (the float sv-48)) arg2))
            )
          (let ((v1-25 arg1))
            (cond
              ((= v1-25 (pickup-type eco-yellow))
               (set! sv-64 (get-process *pickup-dead-pool* eco-yellow #x4000))
               (set! v1-28 (when sv-64
                             (set! sv-192 (the-as (pointer process) v1-28))
                             (let ((t9-4 (method-of-type eco-yellow activate)))
                               (t9-4 (the-as eco-yellow sv-64) arg4 'eco-yellow (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-64 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-64 ppointer))
                             v1-28
                             )
                     )
               sv-192
               )
              ((= v1-25 (pickup-type eco-red))
               (set! sv-80 (get-process *pickup-dead-pool* eco-red #x4000))
               (set! v1-34 (when sv-80
                             (set! sv-192 (the-as (pointer process) v1-34))
                             (let ((t9-7 (method-of-type eco-red activate)))
                               (t9-7 (the-as eco-red sv-80) arg4 'eco-red (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-80 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-80 ppointer))
                             v1-34
                             )
                     )
               (level-hint-spawn
                 (game-text-id misty-eco-red-hint)
                 "sksp0071"
                 (the-as entity #f)
                 *entity-pool*
                 (game-task none)
                 )
               )
              ((= v1-25 (pickup-type eco-pink))
               (set! sv-80 (get-process *pickup-dead-pool* eco-pink #x4000))
               (set! v1-34 (when sv-80
                             (set! sv-192 (the-as (pointer process) v1-34))
                             (let ((t9-7 (method-of-type eco-pink activate)))
                               (t9-7 (the-as eco-pink sv-80) arg4 'eco-pink (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-80 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-80 ppointer))
                             v1-34
                             )
                     )
               (level-hint-spawn
                 (game-text-id misty-eco-red-hint)
                 "sksp0071"
                 (the-as entity #f)
                 *entity-pool*
                 (game-task none)
                 )
               )
              ((= v1-25 (pickup-type eco-blue))
               (set! sv-96 (get-process *pickup-dead-pool* eco-blue #x4000))
               (set! v1-40 (when sv-96
                             (set! sv-192 (the-as (pointer process) v1-40))
                             (let ((t9-11 (method-of-type eco-blue activate)))
                               (t9-11 (the-as eco-blue sv-96) arg4 'eco-blue (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-96 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-96 ppointer))
                             v1-40
                             )
                     )
               sv-192
               )
              ((= v1-25 (pickup-type eco-green))
               (set! sv-112 (get-process *pickup-dead-pool* health #x4000))
               (set! v1-46 (when sv-112
                             (set! sv-192 (the-as (pointer process) v1-46))
                             (let ((t9-14 (method-of-type health activate)))
                               (t9-14 (the-as health sv-112) arg4 'health (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-112 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-112 ppointer))
                             v1-46
                             )
                     )
               sv-192
               )
              ((= v1-25 (pickup-type eco-pill))
               (set! sv-128 (get-process *pickup-dead-pool* eco-pill #x4000))
               (set! v1-52 (when sv-128
                             (set! sv-192 (the-as (pointer process) v1-52))
                             (let ((t9-17 (method-of-type eco-pill activate)))
                               (t9-17 (the-as eco-pill sv-128) arg4 'eco-pill (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-128 initialize-eco-by-other arg0 s1-0 s0-0)
                             (set! sv-192 (-> sv-128 ppointer))
                             v1-52
                             )
                     )
               sv-192
               )
              ((= v1-25 (pickup-type money))
               (set! sv-144 (get-process *pickup-dead-pool* money #x4000))
               (set! v1-58 (when sv-144
                             (set! sv-192 (the-as (pointer process) v1-58))
                             (let ((t9-20 (method-of-type money activate)))
                               (t9-20 (the-as money sv-144) arg4 'money (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-144 money-init-by-other arg0 s1-0 s0-0 (-> self entity))
                             (set! sv-192 (-> sv-144 ppointer))
                             v1-58
                             )
                     )
               sv-192
               )
              ((= v1-25 (pickup-type fuel-cell))
               (set! (-> s0-0 pickup-spawn-amount) arg2)
               (set! sv-160 (get-process *pickup-dead-pool* fuel-cell #x4000))
               (set! v1-64 (when sv-160
                             (set! sv-192 (the-as (pointer process) v1-64))
                             (let ((t9-23 (method-of-type fuel-cell activate)))
                               (t9-23 (the-as fuel-cell sv-160) arg4 'fuel-cell (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-160 fuel-cell-init-by-other arg0 s1-0 s0-0 (-> self entity))
                             (set! sv-192 (-> sv-160 ppointer))
                             v1-64
                             )
                     )
               (set! sv-48 0)
               sv-48
               )
              ((= v1-25 (pickup-type buzzer))
               (set! (-> s0-0 pickup-spawn-amount) arg2)
               (set! sv-176 (get-process *pickup-dead-pool* buzzer #x4000))
               (set! v1-71 (when sv-176
                             (set! sv-192 (the-as (pointer process) v1-71))
                             (let ((t9-26 (method-of-type buzzer activate)))
                               (t9-26 (the-as buzzer sv-176) arg4 'buzzer (the-as pointer #x70004000))
                               )
                             (run-now-in-process sv-176 buzzer-init-by-other arg0 s1-0 s0-0 (-> self entity))
                             (set! sv-192 (-> sv-176 ppointer))
                             v1-71
                             )
                     )
               (set! sv-48 0)
               sv-48
               )
              (else
                (format 0 "ERROR: unknown type of eco ~d~%" arg1)
                #f
                )
              )
            )
          )
        )
      )
    )
  sv-192
  )

  (defmethod initialize vent ((obj vent) (arg0 entity-actor) (arg1 pickup-type))
  (stack-size-set! (-> obj main-thread) 128)
  (logior! (-> obj mask) (process-mask actor-pause))
  (let ((s3-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s2-0 (new 'process 'collide-shape-prim-sphere s3-0 (the-as uint 0))))
      (set! (-> s2-0 prim-core collide-as) (collide-kind powerup))
      (set! (-> s2-0 collide-with) (collide-kind target))
      (set-vector! (-> s2-0 local-sphere) 0.0 4915.2 0.0 6553.6)
      (set-root-prim! s3-0 s2-0)
      )
    (set! (-> s3-0 nav-radius) (* 0.75 (-> s3-0 root-prim local-sphere w)))
    (backup-collide-with-as s3-0)
    (set! (-> obj root-override) s3-0)
    )
  (set! (-> obj root-override trans quad) (-> arg0 extra trans quad))
  (update-transforms! (-> obj root-override))
  (set! (-> obj root-override pause-adjust-distance) 409600.0)
  (set! (-> obj fact) (new 'process 'fact-info obj arg1 (-> *FACT-bank* eco-full-inc)))
  (set! (-> obj block-func) (the-as (function vent symbol) true-func))
  (case (-> obj fact pickup-type)
    (((pickup-type eco-blue))
     (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 44) obj))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 67))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 43))
     (set! (-> obj sound) (new 'process 'ambient-sound 'eco-bg-blue (-> obj root-override trans)))
     )
    (((pickup-type eco-red))
     (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 50) obj))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 69))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 49))
     (set! (-> obj sound) (new 'process 'ambient-sound 'eco-bg-red (-> obj root-override trans)))
     )
    (((pickup-type eco-pink))
     (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 50) obj))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 69))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 49))
     (set! (-> obj sound) (new 'process 'ambient-sound 'eco-bg-red (-> obj root-override trans)))
     )
    (((pickup-type eco-green))
     (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 62) obj))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 66))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 61))
     (set! (-> obj sound) (new 'process 'ambient-sound 'eco-bg-green (-> obj root-override trans)))
     )
    (((pickup-type eco-yellow))
     (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 52) obj))
     (set! (-> obj collect-effect) (-> *part-group-id-table* 68))
     (set! (-> obj collect-effect2) (-> *part-group-id-table* 57))
     (set! (-> obj sound) (new 'process 'ambient-sound 'eco-bg-yellow (-> obj root-override trans)))
     )
    )
  (set! (-> obj blocker) (entity-actor-lookup (-> obj entity) 'alt-actor 0))
  (when (-> obj blocker)
    (logior! (-> obj fact options) (fact-options vent-blocked))
    (set! (-> obj block-func)
          (lambda ((arg0 vent)) (zero? (logand (-> arg0 blocker extra perm status) (entity-perm-status complete))))
          )
    )
  (set! (-> obj show-particles) #t)
  (when (logtest? (-> obj fact options) (fact-options vent-blocked))
    (when (logtest? (-> obj fact options) (fact-options vent-valve))
      (case (-> obj fact pickup-type)
        (((pickup-type eco-blue))
         (set! (-> obj block-func)
               (the-as (function vent symbol) (lambda () (not (task-complete? *game-info* (game-task jungle-eggtop)))))
               )
         )
        (((pickup-type eco-red))
         (set! (-> obj block-func)
               (the-as (function vent symbol) (lambda () (not (task-complete? *game-info* (game-task red-eggtop)))))
               )
         )
        (((pickup-type eco-pink))
         (set! (-> obj block-func)
               (the-as (function vent symbol) (lambda () (not (task-complete? *game-info* (game-task red-eggtop)))))
               )
         )
        (((pickup-type eco-yellow))
         (set! (-> obj block-func)
               (the-as (function vent symbol) (lambda () (not (task-complete? *game-info* (game-task snow-eggtop)))))
               )
         )
        )
      (process-spawn ecovalve (-> obj block-func) :from *pickup-dead-pool* :to obj)
      )
    (if ((-> obj block-func) obj)
        (go vent-blocked)
        )
    )
  (go vent-wait-for-touch)
  (none)
  )

(defbehavior target-powerup-process target ()
  (dummy-10 (-> self water))
  (when (not *weather-off*)
    (case (-> self current-level name)
      (('swamp)
       (update-rain self)
       )
      (('snow)
       (update-snow self)
       )
      )
    )
  (cond
    ((and (= (-> self control ground-pat material) (pat-material ice))
          (and (>= (-> self control unknown-float01) 204.8)
               (< (- (-> *display* base-frame-counter) (-> self control unknown-dword11)) (seconds 0.05))
               )
          )
     (let ((gp-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 74))))
       (if (and (< (fabs
                     (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) gp-0 (-> self control trans))
                       )
                     )
                   819.2
                   )
                (rand-vu-percent? 0.5)
                )
           (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 2391) gp-0)
           )
       )
     (let ((gp-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 70))))
       (if (and (< (fabs
                     (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self control trans))
                       )
                     )
                   819.2
                   )
                (rand-vu-percent? 0.5)
                )
           (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 2391) gp-1)
           )
       )
     ;; PAL patch here
     (let ((f0-8 (lerp-scale 80.0 100.0 (-> self control unknown-float01) 0.0 81920.0)))
       (if (not (ja-group? (-> self draw art-group data 104)))
           (set! f0-8 (* 0.8 f0-8))
           )
       (seek! (-> self control unknown-float141) f0-8 (* 100.0 (-> *display* seconds-per-frame)))
       )
     (let ((f30-0 (-> self control unknown-float141))
           (f0-13 (lerp-scale -0.3 0.3 (-> self control unknown-float01) 0.0 81920.0))
           )
       (sound-play
         "ice-loop"
         :id (-> self control unknown-soundid00)
         :vol f30-0
         :pitch f0-13
         :position (the-as symbol (-> self control trans))
         )
       )
     )
    ((< 0.0 (-> self control unknown-float141))
     (set! (-> self control unknown-float141) 0.0)
     (let ((v1-64 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
       (set! (-> v1-64 command) (sound-command set-param))
       (set! (-> v1-64 id) (-> self control unknown-soundid00))
       (set! (-> v1-64 parms volume) -4)
       (set! (-> v1-64 auto-time) 48)
       (set! (-> v1-64 auto-from) 2)
       (set! (-> v1-64 parms mask) (sound-mask volume time))
       (-> v1-64 id)
       )
     )
    )
  (let ((v1-67 (-> *time-of-day-context* current-shadow))
        (a0-33 (-> self draw shadow-ctrl))
        )
    (set! (-> a0-33 settings shadow-dir x) (-> v1-67 x))
    (set! (-> a0-33 settings shadow-dir y) (-> v1-67 y))
    (set! (-> a0-33 settings shadow-dir z) (-> v1-67 z))
    )
  (when (and (!= (-> self fact-info-target eco-level) 0.0)
             (>= (- (-> *display* game-frame-counter) (-> self fact-info-target eco-pickup-time))
                 (the-as time-frame (-> self fact-info-target eco-timeout))
                 )
             )
    (set! (-> self fact-info-target eco-level) 0.0)
    (set! (-> self fact-info-target eco-timeout) 0)
    (logclear! (-> self state-flags) (state-flags invuln-powerup))
    (send-event self 'reset-collide)
    (stop! (-> self sound))
    )
  (when (and (< 0.0 (-> self fact-info-target eco-level))
             (zero? (logand (-> self state-flags) (state-flags first-person-mode)))
             (zero? (logand (-> self draw status) (draw-status hidden no-anim)))
             (not (movie?))
             (rand-vu-percent?
               (lerp-scale
                 0.0
                 1.0
                 (the float (- (-> self fact-info-target eco-timeout)
                               (the-as uint (- (-> *display* game-frame-counter) (-> self fact-info-target eco-pickup-time)))
                               )
                      )
                 0.0
                 900.0
                 )
               )
             )
    (case (-> self fact-info-target eco-type)
      (((pickup-type eco-yellow))
       (change-sound! (-> self sound) (static-sound-name "yel-eco-jak"))
       (let ((s4-0 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* (if (rand-vu-percent? 0.5) 269 270))
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data s4-0))
                           )
         )
       (dotimes (gp-4 2)
         (let ((v1-111 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
           (launch-particles (-> *part-id-table* 271)
                             (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-111))
                             )
           )
         )
       )
      (((pickup-type eco-red))
       (target-danger-set! (-> self control unknown-symbol30) #t)
       (update-transforms! (-> self control))
       (let ((a1-23 (new 'stack-no-clear 'touching-shapes-entry)))
         (set! (-> a1-23 cshape1) (the-as collide-shape 0))
         (set! (-> a1-23 cshape2) (the-as collide-shape *touching-list*))
         (find-overlapping-shapes (-> self control) (the-as overlaps-others-params a1-23))
         )
       (target-danger-set! (-> self control unknown-symbol30) #f)
       (update-transforms! (-> self control))
       (change-sound! (-> self sound) (static-sound-name "red-eco-jak"))
       (let ((s4-2 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* (if (rand-vu-percent? 0.5) 273 274))
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data s4-2))
                           )
         )
       (dotimes (gp-6 2)
         (let ((v1-139 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
           (launch-particles (-> *part-id-table* 275)
                             (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-139))
                             )
           )
         )
       )
 (((pickup-type eco-pink))
       (target-danger-set! (-> self control unknown-symbol30) #t)
       (update-transforms! (-> self control))
       (let ((a1-23 (new 'stack-no-clear 'touching-shapes-entry)))
         (set! (-> a1-23 cshape1) (the-as collide-shape 0))
         (set! (-> a1-23 cshape2) (the-as collide-shape *touching-list*))
         (find-overlapping-shapes (-> self control) (the-as overlaps-others-params a1-23))
         )
       (target-danger-set! (-> self control unknown-symbol30) #f)
       (update-transforms! (-> self control))
       (change-sound! (-> self sound) (static-sound-name "red-eco-jak"))
       (let ((s4-2 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* (if (rand-vu-percent? 0.5) 273 274))
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data s4-2))
                           )
         )
       (dotimes (gp-6 2)
         (let ((v1-139 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
           (launch-particles (-> *part-id-table* 275)
                             (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-139))
                             )
           )
         )
       )
      (((pickup-type eco-blue))
       (change-sound! (-> self sound) (static-sound-name "blue-eco-jak"))
       (let ((v1-150 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (cond
           ((and (logtest? (-> self control unknown-surface00 flags) (surface-flags jump))
                 (zero? (logand (-> self control status) (cshape-moving-flags onsurf)))
                 )
            (set! (-> *part-id-table* 259 init-specs 4 initial-valuef) 0.0)
            (set! (-> *part-id-table* 259 init-specs 4 random-rangef) 65536.0)
            )
           (else
             (set! (-> *part-id-table* 259 init-specs 4 initial-valuef) 40960.0)
             (set! (-> *part-id-table* 259 init-specs 4 random-rangef) 16384.0)
             )
           )
         (launch-particles (-> *part-id-table* 259) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-150))
)
         )
       (let ((gp-8 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* (if (rand-vu-percent? 0.5) 255 256))
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data gp-8))
                           )
         (if (rand-vu-percent? 0.5)
             (launch-particles  (-> *part-id-table* 257)
                                (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data gp-8))
                                )
             )
         )
       (let ((v1-168 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* 260)
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-168))
                           )
         )
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 1 (seconds 0.1))
       )
      (((pickup-type eco-green))
       (change-sound! (-> self sound) (static-sound-name "green-eco-jak"))
       (let ((s4-8 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
         (launch-particles (-> *part-id-table* (if (rand-vu-percent? 0.5) 277 278))
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data s4-8)))
         )
       (dotimes (gp-11 2)
         (let ((v1-188 (rand-vu-int-range 3 (+ (-> self node-list length) -1))))
           (launch-particles (-> *part-id-table* 279) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data v1-188)))
           )
         )
       )
      )
    (update-trans! (-> self sound) (-> self control trans))
    (update! (-> self sound))
    )
  0
  (none)
  )

  
(defmethod pickup-collectable! fact-info-target ((obj fact-info-target) (kind pickup-type) (amount float) (source-handle handle))
  "Pickup a thing!"
  (case kind
    (((pickup-type eco-green))
     ;; big green eco.  This counts toward the health (up to 3), and if that's full, maxes out the little green ecos to 50.
     (cond
       ((>= amount 0.0)
        ;; got a positive or 0 amount.
        (when (< 0.0 amount)
          ;; when we get a different source, OR we it's been more than 0.5 seconds since we last got eco
          ;; from this source.
          (if (or (!= (handle->process source-handle) (handle->process (-> obj eco-source)))
                  (>= (- (-> *display* base-frame-counter) (-> obj eco-source-time)) (seconds 0.5))
                  )

              ;; play the sound!
              (sound-play "get-green-eco")
              )

          ;; remember the source.
          (when (handle->process source-handle)
            (set! (-> obj eco-source) source-handle)
            (set! (-> obj eco-source-time) (-> *display* base-frame-counter))
            )
          )

        ;; if we are at max health (3), and collect additional an additional big green eco,
        ;; then max out the little green ecos.
        (if (= (-> obj health) (-> obj health-max))
            (pickup-collectable!
              obj
              (pickup-type eco-pill)
              (-> *FACT-bank* eco-pill-max-default)
              (process->handle (-> obj process))
              )
            )

        ;; remember when
        (set! (-> obj health-pickup-time) (-> *display* base-frame-counter))
        ;; increase the health!
        (seek! (-> obj health) (-> obj health-max) amount)
        )
       (else
         ;; negative health. Subtract.
         (seek! (-> obj health) 0.0 (- amount))

         ;; not sure why we do this. But this will set the eco pill collection time.
         (if (>= amount -10.0)
             (pickup-collectable! obj (pickup-type eco-pill) 0.0 source-handle)
             )

         ;; subtract lives.
         (if (= (-> obj health) 0.0)
             (adjust (-> (the-as target (-> obj process)) game) 'life (- (-> *GAME-bank* life-single-inc)) source-handle)
             )
         )
       )

     ;; some sort of hack for eco vents.
     (b!
       (and (logtest? (-> (the-as collide-shape (-> obj process root)) root-prim prim-core action) (collide-action ca-9))
            (type-type? (-> (handle->process source-handle) type) vent)
            )
       cfg-80
       :delay (nop!)
       )
     (-> obj health)
     )

    (((pickup-type eco-pill))
     ;; collect small green eco
     (when (>= amount 0.0)
       ;; update small eco count
       (set! (-> obj eco-pill-pickup-time) (-> *display* base-frame-counter))
       (seek! (-> obj eco-pill) (-> obj eco-pill-max) amount)

       ;; increment big health if needed
       (when (and (>= (-> obj eco-pill) (-> *FACT-bank* eco-pill-max-default)) (< (-> obj health) (-> obj health-max)))
         ;; decrease eco pills
         (set! (-> obj eco-pill) (- (-> obj eco-pill) (-> *FACT-bank* eco-pill-max-default)))
         ;; get a big health.
         (pickup-collectable!
           obj
           (pickup-type eco-green)
           (-> *FACT-bank* health-small-inc)
           (process->handle (-> obj process))
           )
         )
       )
     (-> obj eco-pill)
     )

    (((pickup-type money))
     ;; get money.
     (when (< 0.0 amount)
       ;; play sound.
       (if (>= (- (-> *display* base-frame-counter) (-> obj money-pickup-time)) (seconds 0.05))
           (sound-play "money-pickup")
           )
       (set! (-> obj money-pickup-time) (-> *display* base-frame-counter))
       )
     (adjust (-> (the-as target (-> obj process)) game) 'money amount source-handle)
     )
    (((pickup-type fuel-cell))
     ;; the amount is actually the index of the task.
     (let ((s4-2 (the int amount)))
       (if (not (or (task-complete? (-> (the-as target (-> obj process)) game) (the-as game-task s4-2))
                    (>= (the-as uint 1) (the-as uint s4-2))
                    )
                )
           (set! (-> obj fuel-cell-pickup-time) (-> *display* base-frame-counter))
           )
       )
     (adjust (-> (the-as target (-> obj process)) game) 'fuel-cell amount source-handle)
     )
    (((pickup-type buzzer))
     ;; buzzer
     (let ((buzz-count (adjust (-> (the-as target (-> obj process)) game) 'buzzer amount source-handle)))
       (if (!= buzz-count (-> obj buzzer))
           (set! (-> obj buzzer-pickup-time) (-> *display* base-frame-counter))
           )
       (set! (-> obj buzzer) buzz-count)
       )
     (-> obj buzzer)
     )
    (((pickup-type eco-red) (pickup-type eco-blue) (pickup-type eco-yellow) (pickup-type eco-pink))
     ;; the green vent jumps here.
     (label cfg-80)

     ;; if the amount is zero, we just want to know how much eco there is.
     (if (= amount 0.0)
         (return (if (= (-> obj eco-type) kind)
                     (-> obj eco-level)
                     0.0 ;; we don't have this kind of eco.
                     )
                 )
         )

     ;; new type of eco. Reset and use the new type.
     (when (!= (-> obj eco-type) kind)
       ;; as far as I can tell, the eco-level isn't really used other than just 1 or 0.
       (set! (-> obj eco-level) 0.0)
       (set! (-> obj eco-timeout) 0)
       )
     (set! (-> obj eco-type) kind)


     (let ((eco-lev (-> obj eco-level)))
       (set! (-> obj eco-level) 1.0) ;; just set to 1.

       ;; this check now doesn't make much sense...
       (when (and (= eco-lev 0.0) (< 0.0 (-> obj eco-level)))
         ;; didn't have eco and now we do, remember when
         (set! (-> obj eco-pickup-time) (-> *display* game-frame-counter))

         ;; send a reset-collide message. Not sure why we do this.
         (send-event (-> obj process) 'reset-collide)
         )

       ;; this logic prevents eco from respawning before you are out.
       ;; the time until respawn is min(full_eco_time, old_time + single_timeout)
       (set! (-> obj eco-timeout)
             (the-as seconds
                     (min (the-as int (+ (-> obj eco-timeout) (* (the-as int (-> *FACT-bank* eco-single-timeout)) (the int amount))))
                          (the-as int (+ (-> *FACT-bank* eco-full-timeout) (- (-> *display* game-frame-counter) (-> obj eco-pickup-time))))
                          )
                     )
             )

       ;; if you max out the eco, this should trigger
       (if (>= (the-as int (- (-> obj eco-timeout) (the-as uint (- (-> *display* game-frame-counter) (-> obj eco-pickup-time)))))
               (the-as int (-> *FACT-bank* eco-full-timeout))
               )
           (set! (-> obj eco-level) 2.0)
           )


       ;; sound and controller vibration.
       (when (not (and (= (handle->process source-handle) (handle->process (-> obj eco-source)))
                       (< (- (-> *display* base-frame-counter) (-> obj eco-source-time)) (seconds 0.5))
                       )
                  )
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.2))
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 17 (seconds 0.2))
         (case kind
           (((pickup-type eco-blue))
            (sound-play "get-blue-eco")
            )
           (((pickup-type eco-green))
            (sound-play "get-green-eco")
            )
           (((pickup-type eco-yellow))
            (sound-play "get-yellow-eco")
            )
           (((pickup-type eco-red))
            (sound-play "get-red-eco")
            )
           (((pickup-type eco-pink))
            (sound-play "get-green-eco")
            )
           )
         )

       (set! (-> obj eco-source) source-handle)
       (set! (-> obj eco-source-time) (-> *display* base-frame-counter))

       ;; special case for blue eco magnet effect
       (when (= kind (pickup-type eco-blue))
         (when (= eco-lev 0.0)
           (let ((s5-1 (-> obj process)))
             (let ((s4-3
                     (process-spawn
                       touch-tracker
                       :init touch-tracker-init
                       (-> s5-1 root trans)
                       (-> *FACT-bank* suck-bounce-dist)
                       (seconds 1)
                       :to s5-1
                       )
                     )
                   )
               (send-event (ppointer->process s4-3) 'target s5-1)
               (send-event (ppointer->process s4-3) 'event 'eco-blue)
               (send-event (ppointer->process s4-3) 'exit (lambda () (send-event *target* 'query 'powerup (pickup-type eco-blue))))
               (send-event
                 (ppointer->process s4-3)
                 'eval
                 (lambda :behavior process-drawable
                   ()
                   (set! (-> (the-as collide-shape (-> self root)) root-prim collide-with)
                         (collide-kind cak-1 cak-2 cak-3 blue-eco-suck)
                         )
                   (none)
                   )
                 )
               )
             (process-spawn-function
               process
               (lambda ((arg0 process-drawable))
                 (let ((s5-0 (-> *display* base-frame-counter)))
                   (until (>= (- (-> *display* base-frame-counter) s5-0) (seconds 0.6))
                     (send-event arg0 'effect 'eco-blue)
                     (suspend)
                     )
                   )
                 (none)
                 )
               s5-1
               :from *4k-dead-pool*
               :to s5-1
               )
             )
           )
         )
       )
     (-> obj eco-level)
     )
    (else
      ((method-of-type fact-info pickup-collectable!) obj kind amount source-handle)
      )
    )
  )



